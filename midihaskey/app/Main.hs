{-# LANGUAGE UnicodeSyntax #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE DuplicateRecordFields #-}

module Main (main) where -- "midihaskey" app

import Prelude.Unicode

import Data.Default (def)
import Text.InterpolatedString.QM

import Control.Monad
import Control.Concurrent

import System.Environment (getArgs)
import System.IO (hPutStrLn, stderr)

-- local
import MIDIHasKey.Utils
import Types
import GUI
import MIDIPlayer
import HandleKeyboard
import EventHandler
import Keys.Types
import MIDIHasKey.Config


main ‚à∑ IO ()
main = do
  (appExitBus        ‚à∑ MVar ())             ‚Üê newEmptyMVar
  (guiStateUpdateBus ‚à∑ MVar GUIStateUpdate) ‚Üê newEmptyMVar
  (alertsBus         ‚à∑ MVar AlertMessage)   ‚Üê newEmptyMVar

  !(config ‚à∑ Config) ‚Üê
    readConfig >>= \case
      Right config ‚Üí pure config
      Left  errMsg ‚Üí def <$ alertsBus `putMVar`
        ErrorAlert [qms| Parsing config failed with message: {errMsg} |]

  evIface ‚Üê runMIDIPlayer >>= \sendToMP ‚Üí

    let evListener ‚à∑ EventToHandle ‚Üí AppState ‚Üí IO ()

        evListener (KeyPress   key) _ = guiUpdate $ KeyButtonState key True
        evListener (KeyRelease key) _ = guiUpdate $ KeyButtonState key False

        evListener (NewBaseKey k) s = do
          guiUpdate $ SetBaseKey k
          guiUpdate $ SetPitchMapping $ pitchMap s

        evListener (NewBasePitch p) s = do
          guiUpdate $ SetBasePitch p
          guiUpdate $ SetPitchMapping $ pitchMap s

        evListener (NewOctave o) s = do
          guiUpdate $ SetOctave o
          guiUpdate $ SetPitchMapping $ pitchMap s

        evListener (NewBaseOctave o) s = do
          guiUpdate $ SetBaseOctave o
          guiUpdate $ SetPitchMapping $ pitchMap s

        evListener (NewNotesPerOctave n) s = do
          guiUpdate $ SetNotesPerOctave n
          guiUpdate $ SetPitchMapping $ pitchMap s

        evListener (NewChannel ch)  _ = guiUpdate $ SetChannel ch
        evListener (NewVelocity v)  _ = guiUpdate $ SetVelocity v
        evListener SaveConfig       s = guiUpdate $ NewLastSavedState $ getGUIState s

        evListener _ _ = pure ()

        guiUpdate = putMVar guiStateUpdateBus

     in runEventHandler EventHandlerContext { sendToMIDIPlayer = sendToMP
                                            , eventsListener   = evListener
                                            , onNewAppState    = const $ pure () -- TODO
                                            , initialConfig    = config
                                            }

  let sendToEventHandler = handleEvent evIface

      keyHandler ‚à∑ RowKey ‚Üí ùîπ ‚Üí IO ()
      keyHandler rowKey isPressed =
        let ev = if isPressed then KeyPress rowKey else KeyRelease rowKey
         in void $ forkIO $ sendToEventHandler ev

  getArgs >>= \x ‚Üí runKeyboardHandling HandleKeyboardContext { devices = x
                                                             , handleKeyboardKeyEvent = keyHandler
                                                             }

  guiInitValues ‚Üê getAppState evIface <&> getGUIState

  guiIface ‚Üê
    runGUI GUIContext { initialState             = guiInitValues
                      , appExitHandler           = void $ forkIO $ putMVar appExitBus ()
                      , panicButtonHandler       = void $ forkIO $ sendToEventHandler PanicEvent
                      , saveConfigButtonHandler  = void $ forkIO $ sendToEventHandler SaveConfig

                      , setBaseKeyHandler        = void ‚àò forkIO ‚àò sendToEventHandler ‚àò NewBaseKey
                      , setBasePitchHandler      = void ‚àò forkIO ‚àò sendToEventHandler ‚àò NewBasePitch
                      , setOctaveHandler         = void ‚àò forkIO ‚àò sendToEventHandler ‚àò NewOctave

                      , setBaseOctaveHandler     = void ‚àò forkIO ‚àò sendToEventHandler
                                                 ‚àò NewBaseOctave

                      , setNotesPerOctaveHandler = void ‚àò forkIO ‚àò sendToEventHandler
                                                 ‚àò NewNotesPerOctave

                      , selectChannelHandler     = void ‚àò forkIO ‚àò sendToEventHandler ‚àò NewChannel

                      , noteButtonHandler        = keyHandler
                      }

  void $ forkIO $ catchThreadFail [] "Main module listener for GUI state updates" $ forever $
    takeMVar guiStateUpdateBus >>= guiStateUpdate guiIface

  -- void $ forkIO $ catchThreadFail [] "Main module listener for alerts bus" $ forever $
  --   takeMVar alertsBus >>= guiShowAlert guiIface
  -- It's commented because it fails with `BlockedIndefinitelyOnMVar` exception.
  tryTakeMVar alertsBus >>= maybeMUnit (guiShowAlert guiIface)

  takeMVar appExitBus
  hPutStrLn stderr "Application is terminating‚Ä¶"


getGUIState ‚à∑ AppState ‚Üí GUIState
getGUIState appState
  = GUIState
  { guiStateBaseKey        = baseKey        (appState ‚à∑ AppState)
  , guiStateBasePitch      = basePitch      (appState ‚à∑ AppState)
  , guiStateOctave         = octave         (appState ‚à∑ AppState)
  , guiStateBaseOctave     = baseOctave     (appState ‚à∑ AppState)
  , guiStateNotesPerOctave = notesPerOctave (appState ‚à∑ AppState)

  , guiStatePitchMapping   = pitchMap       (appState ‚à∑ AppState)

  , guiStateChannel        = channel        (appState ‚à∑ AppState)
  , guiStateVelocity       = velocity       (appState ‚à∑ AppState)
  }
